name: Agentic QE - Test Execution

on:
  workflow_dispatch:
    inputs:
      test_ids:
        description: 'Comma-separated test case IDs'
        required: true
        type: string
      triggered_by:
        description: 'Who triggered this execution'
        required: false
        default: 'manual'
        type: string

jobs:
  execute-tests:
    runs-on: self-hosted
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.16.0'
          cache: 'npm'
      
      - name: Install dependencies
        shell: powershell
        run: |
          Write-Host "Checking for package-lock.json..."
          if (Test-Path "package-lock.json") {
            Write-Host "Found package-lock.json, using npm ci"
            npm ci --legacy-peer-deps
          } else {
            Write-Host "No package-lock.json found, using npm install"
            npm install --legacy-peer-deps
          }
      
      - name: Install Playwright
        shell: powershell
        run: |
          $playwrightInstalled = npm list @playwright/test 2>$null
          if (-not $playwrightInstalled) {
            Write-Host "Installing Playwright..."
            npm install --save-dev @playwright/test --legacy-peer-deps
          } else {
            Write-Host "Playwright already installed"
          }
          # Install TypeScript support if needed
          $tsInstalled = npm list typescript 2>$null
          if (-not $tsInstalled) {
            Write-Host "Installing TypeScript..."
            npm install --save-dev typescript @types/node --legacy-peer-deps
          }
          # Install ts-node or @swc/core for TypeScript config compilation
          $tsNodeInstalled = npm list ts-node 2>$null
          $swcInstalled = npm list @swc/core 2>$null
          if (-not $tsNodeInstalled -and -not $swcInstalled) {
            Write-Host "Installing ts-node for TypeScript config support..."
            try {
              npm install --save-dev ts-node --legacy-peer-deps
            } catch {
              npm install --save-dev @swc/core @swc/helpers --legacy-peer-deps
            }
          }
          Write-Host "Installing Playwright browsers..."
          npx playwright install --with-deps
      
      - name: Create or update Playwright config for headed mode
        shell: powershell
        run: |
          $configFile = $null
          if (Test-Path "playwright.config.ts") {
            $configFile = "playwright.config.ts"
          } elseif (Test-Path "playwright.config.js") {
            $configFile = "playwright.config.js"
          } elseif (Test-Path "playwright.config.mjs") {
            $configFile = "playwright.config.mjs"
          }
          
          if (-not $configFile) {
            Write-Host "Creating basic Playwright config (TypeScript format)..."
            $configContent = @"
          import { defineConfig, devices } from '@playwright/test';

          /**
           * See https://playwright.dev/docs/test-configuration.
           */
          export default defineConfig({
            testDir: './src/tests',
            /* Run tests in files in parallel */
            fullyParallel: true,
            /* Fail the build on CI if you accidentally left test.only in the source code. */
            forbidOnly: !!process.env.CI,
            /* Retry on CI only */
            retries: process.env.CI ? 2 : 0,
            /* Opt out of parallel tests on CI. */
            workers: process.env.CI ? 1 : undefined,
            /* Reporter to use. See https://playwright.dev/docs/test-reporters */
            reporter: 'html',
            /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
            use: {
              /* Base URL to use in actions like `await page.goto('/')`. */
              // baseURL: 'http://127.0.0.1:3000',

              /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
              trace: 'on-first-retry',
              /* Run in headed mode (show browser) */
              headless: false,
            },

            /* Configure projects for major browsers */
            projects: [
              {
                name: 'chromium',
                use: { 
                  ...devices['Desktop Chrome'],
                  headless: false,
                },
              },

              // {
              //   name: 'firefox',
              //   use: { ...devices['Desktop Firefox'] },
              // },

              // {
              //   name: 'webkit',
              //   use: { ...devices['Desktop Safari'] },
              // },
            ],
          });
          "@
            Set-Content -Path "playwright.config.ts" -Value $configContent
            Write-Host "Created playwright.config.ts with headless: false"
          } else {
            Write-Host "Found existing config: $configFile"
            $configContent = Get-Content $configFile -Raw
            
            # Check if headless is set to false
            $needsUpdate = $false
            $updatedContent = $configContent
            
            # Replace headless: true with headless: false
            if ($configContent -match "headless[:\s]*true") {
              Write-Host "Updating headless: true to headless: false..."
              $updatedContent = $updatedContent -replace "headless[:\s]*true", "headless: false"
              $needsUpdate = $true
            }
            
            # Ensure headless: false is in the use section
            if ($updatedContent -notmatch "use:\s*\{[^}]*headless[:\s]*false") {
              Write-Host "Ensuring headless: false is in use section..."
              # Try to add it after trace or baseURL comment
              if ($updatedContent -match "(use:\s*\{[^}]*)(trace[^,}]+)") {
                $updatedContent = $updatedContent -replace "(use:\s*\{[^}]*)(trace[^,}]+)", "`$1`$2,`n              headless: false"
                $needsUpdate = $true
              } elseif ($updatedContent -match "(use:\s*\{)") {
                $updatedContent = $updatedContent -replace "(use:\s*\{)", "`$1`n              headless: false,"
                $needsUpdate = $true
              }
            }
            
            # Ensure headless: false is in chromium project
            if ($updatedContent -match "name:\s*['\`"]chromium['\`"]") {
              if ($updatedContent -notmatch "name:\s*['\`"]chromium['\`"][^}]*headless[:\s]*false") {
                Write-Host "Ensuring headless: false is in chromium project..."
                if ($updatedContent -match "(name:\s*['\`"]chromium['\`"][^}]*use:\s*\{[^}]*)(\.\.\.devices)") {
                  $updatedContent = $updatedContent -replace "(name:\s*['\`"]chromium['\`"][^}]*use:\s*\{[^}]*)(\.\.\.devices)", "`$1`$2,`n                  headless: false"
                  $needsUpdate = $true
                }
              }
            }
            
            if ($needsUpdate) {
              Set-Content -Path $configFile -Value $updatedContent
              Write-Host "Updated $configFile to ensure headless: false"
            } else {
              Write-Host "Config already has headless: false configured"
            }
          }
      
      - name: Verify GUI access for headed mode
        shell: powershell
        run: |
          Write-Host "=========================================="
          Write-Host "Checking GUI access for browser execution"
          Write-Host "=========================================="
          Write-Host ""
          
          # Check if explorer process exists (indicates GUI session)
          $explorer = Get-Process -Name "explorer" -ErrorAction SilentlyContinue
          if ($explorer) {
            Write-Host "[OK] GUI session detected - browser should be able to open"
            Write-Host "     Explorer process found: $($explorer.Count) instance(s)"
          } else {
            Write-Host "[WARNING] No GUI session detected"
            Write-Host "          Browser may not open even with headless: false"
            Write-Host "          Configure the runner service to run under your user account"
          }
          Write-Host ""
          
          # Check current user context
          $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
          Write-Host "Current user context: $currentUser"
          
          # Check if running in service context
          $isService = [System.Environment]::UserName -eq "SYSTEM" -or $env:USERNAME -eq "SYSTEM"
          if ($isService) {
            Write-Host "[WARNING] Running as SYSTEM - may not have GUI access"
            Write-Host "          To fix: Configure the GitHub Actions runner service"
            Write-Host "          to run under your user account in services.msc"
          } else {
            Write-Host "[OK] Running as user account - should have GUI access"
          }
          Write-Host ""
          
          # Check GitHub Actions runner service configuration
          $service = Get-Service | Where-Object {$_.DisplayName -like "*GitHub*Actions*" -or $_.Name -like "*actions*runner*"}
          if ($service) {
            Write-Host "GitHub Actions Runner Service Status:"
            Write-Host "  Service Name: $($service.DisplayName)"
            Write-Host "  Status: $($service.Status)"
            
            try {
              $serviceObj = Get-WmiObject Win32_Service -Filter "Name='$($service.Name)'" -ErrorAction SilentlyContinue
              if ($serviceObj) {
                Write-Host "  Service Account: $($serviceObj.StartName)"
                if ($serviceObj.StartName -eq "LocalSystem" -or $serviceObj.StartName -like "*SYSTEM*") {
                  Write-Host "  [WARNING] Service is running as SYSTEM/LocalSystem"
                  Write-Host "            This may prevent GUI access"
                  Write-Host "            Recommendation: Configure service to run under your user account"
                } else {
                  Write-Host "  [OK] Service is running under user account: $($serviceObj.StartName)"
                }
              }
            } catch {
              Write-Host "  (Could not retrieve service details)"
            }
          } else {
            Write-Host "[INFO] No GitHub Actions service found"
            Write-Host "       Runner may be running as a user process (which is good for GUI access)"
          }
          Write-Host ""
          
          # Check for active desktop session
          try {
            $desktopSession = Get-Process -Name "explorer" -ErrorAction SilentlyContinue
            if ($desktopSession) {
              Write-Host "[OK] Active desktop session detected"
            } else {
              Write-Host "[WARNING] No active desktop session found"
              Write-Host "          Ensure the Windows user is logged in and the screen is not locked"
            }
          } catch {
            Write-Host "[INFO] Could not verify desktop session"
          }
          Write-Host ""
          
          # Display environment variables related to GUI
          Write-Host "Environment variables:"
          Write-Host "  USERNAME: $env:USERNAME"
          Write-Host "  USERPROFILE: $env:USERPROFILE"
          Write-Host "  SESSIONNAME: $env:SESSIONNAME"
          Write-Host ""
          
          Write-Host "=========================================="
          Write-Host "GUI Access Check Complete"
          Write-Host "=========================================="
          Write-Host ""
          Write-Host "If browser does not open, ensure:"
          Write-Host "  1. The runner service runs under your user account (not SYSTEM)"
          Write-Host "  2. Your Windows user session is active and logged in"
          Write-Host "  3. The screen is not locked"
          Write-Host ""
      
      - name: Run Playwright tests
        shell: powershell
        env:
          PLAYWRIGHT_HEADED: "1"
        run: |
          Write-Host "=========================================="
          Write-Host "Running Playwright tests: ${{ inputs.test_ids }}"
          Write-Host "=========================================="
          Write-Host "Current directory: $(Get-Location)"
          Write-Host "Environment variable PLAYWRIGHT_HEADED: $env:PLAYWRIGHT_HEADED"
          Write-Host ""
          
          # Verify Playwright config settings
          if (Test-Path "playwright.config.ts") {
            Write-Host "Playwright config verification:"
            $config = Get-Content "playwright.config.ts" -Raw
            if ($config -match "headless[:\s]*false") {
              Write-Host "  [OK] headless: false found in config"
            } else {
              Write-Host "  [WARNING] headless: false NOT found in config"
            }
            if ($config -match "headless[:\s]*true") {
              Write-Host "  [WARNING] headless: true found in config (will override false)"
            }
          } elseif (Test-Path "playwright.config.js") {
            Write-Host "Playwright config (JS) found"
          } elseif (Test-Path "playwright.config.mjs") {
            Write-Host "Playwright config (MJS) found"
          } else {
            Write-Host "[WARNING] No Playwright config file found"
          }
          Write-Host ""
          
          # Check if tests directory exists
          if (-not (Test-Path "src/tests")) {
            Write-Host "Tests directory not found. Creating it..."
            New-Item -ItemType Directory -Path "src/tests" -Force | Out-Null
          }
          
          # List all files in tests directory for debugging
          Write-Host ""
          Write-Host "Files in tests directory:"
          if (Test-Path "src/tests") {
            $allFiles = Get-ChildItem -Path "src/tests" -Recurse -File | Select-Object FullName
            if ($allFiles) {
              foreach ($file in $allFiles) {
                Write-Host "   - $($file.FullName)"
              }
            } else {
              Write-Host "   (no files found)"
            }
          } else {
            Write-Host "   (directory doesn't exist)"
          }
          Write-Host ""
          
          $testIds = "${{ inputs.test_ids }}".Split(',')
          $exitCode = 0
          $testsFound = 0
          
          foreach ($testId in $testIds) {
            $testId = $testId.Trim()
            Write-Host "Executing test: $testId"
            
            # Find test file matching the test ID
            # Search for each pattern separately since -Include can be finicky
            $testFile = $null
            $patterns = @("*$testId*.spec.ts", "*$testId*.spec.js", "*$testId*.spec.mjs")
            
            # Also try without .spec extension
            $patterns += @("*$testId*.ts", "*$testId*.js")
            
            foreach ($pattern in $patterns) {
              if (-not $testFile) {
                $found = Get-ChildItem -Path "src/tests" -Recurse -Filter $pattern -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($found) {
                  $testFile = $found
                  break
                }
              }
            }
            
            if ($testFile) {
              Write-Host "Found test file: $($testFile.FullName)"
              $testsFound++
              try {
                # Since Playwright config has testDir: './src/tests', 
                # we need to pass path relative to that directory or use filename
                $fileName = $testFile.Name
                $fileDir = $testFile.DirectoryName
                
                # Check if file is in src/tests directory
                if ($fileDir -like "*\src\tests*" -or $fileDir -like "*/src/tests*") {
                  # Use just the filename since testDir is already set to src/tests
                  Write-Host "File is in src/tests, using filename: $fileName"
                  npx playwright test "$fileName" --headed
                } else {
                  # Use relative path from repo root
                  $repoRoot = (Get-Location).Path
                  $relativePath = $testFile.FullName.Replace($repoRoot, "").TrimStart("\", "/").Replace("\", "/")
                  Write-Host "Using relative path: $relativePath"
                  npx playwright test "$relativePath" --headed
                }
                
                $testExitCode = $LASTEXITCODE
                
                if ($testExitCode -ne 0) {
                  Write-Host "Test execution returned exit code: $testExitCode"
                  $exitCode = $testExitCode
                }
              } catch {
                Write-Host "Test execution failed: $_"
                $exitCode = 1
              }
            } else {
              Write-Host "Test file not found for: $testId"
              Write-Host "   Searched for patterns: $($patterns -join ', ')"
              $exitCode = 1
            }
          }
          
          if ($testsFound -eq 0) {
            Write-Host "No test files found. Make sure your test files are in the 'src/tests' directory and named like: src/tests/XSP-16-TC01.spec.ts"
            Write-Host ""
            Write-Host "Tips:"
            Write-Host "   - Test files should be in the 'src/tests' directory"
            Write-Host "   - File names should contain the test ID (e.g., XSP-16-TC01)"
            Write-Host "   - Supported extensions: .spec.ts, .spec.js, .spec.mjs, .ts, .js"
            exit 1
          }
          
          exit $exitCode
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            test-results/
            playwright-report/
          retention-days: 30
          if-no-files-found: ignore
      
      - name: Publish test report
        if: always()
        shell: powershell
        run: |
          Write-Host "Test execution completed"
          Write-Host "Framework: Playwright"
          Write-Host "Test IDs: ${{ inputs.test_ids }}"
          Write-Host "Triggered by: ${{ inputs.triggered_by }}"
